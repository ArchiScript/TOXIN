{"version":3,"file":"232.5411222ca0e0b9888f90.js","mappings":";gHACA,ujPADaA,EAAW,WACtB,WAAYC,GAAoB,IAAlC,IAAoBC,EAAU,UAAH,6CAAG,CAAC,GAA/B,4FAAgC,SAAhC,mHAAgC,KAAhC,EAAgC,GAAhC,SACIC,KAAKF,KAAOA,EACZE,KAAKD,QAAUA,CACjB,CAHF,QAkEG,EATA,EAmBA,OA5EH,EAGG,EAHH,EAGG,mBAED,WACE,MAAqB,SAAdC,KAAKF,IACd,GAAC,yBACD,WAEE,IADA,IAAIG,EAAO,GACFC,EAAI,EAAGA,EAAI,IAAKA,IACvBD,EAAKE,KAAKD,GAEZ,OAAOD,CACT,GAAC,2BAaD,SAAcG,GACZJ,KAAKD,QAAUK,CACjB,GAAC,0BACD,SAAaH,GAAM,WA0BjB,OAzBqBA,EAAKI,QAAO,SAACC,GAChC,IAAK,IAAIC,KAAO,EAAKR,QAAS,CAC5B,IAAMS,EAAc,EAAKT,QAAQQ,GAC3BE,EAAYH,EAAKC,GAEvB,GACyB,WAAvB,EAAOC,IACPA,EAAYE,eAAe,QAC3BF,EAAYE,eAAe,OAC3B,CACA,IAAMC,EAAMH,EAAYG,IAClBC,EAAMJ,EAAYI,IAGxB,GAAIH,EAAYE,GAAOF,EAAYG,EACjC,OAAO,CAEX,MACE,GAAIH,IAAcD,EAChB,OAAO,CAGb,CACA,OAAO,CACT,GAEF,GAAC,oCAED,+GAE+BR,KAAI,UAAJA,MAAI,OAAzBa,EAAe,EAAH,KAClBC,QAAQC,IAAIF,GAAc,gDAE1BC,QAAQE,MAAM,+BAAgC,EAAF,IAAS,yDAExD,iFAED,+GAE+BhB,KAAI,UAAJA,MAAI,OAAb,OAAZa,EAAe,EAAH,uBACXA,GAAY,OAEwC,MAFxC,yBAEnBC,QAAQE,MAAM,qCAAsC,EAAF,IAAS,8DAG9D,8CA5EH,uEA4EG,EA7EqB,GA8EvB,yDArDmD,OAqDnD,6HA5D4BC,MAAM,+BAA8B,OAA7C,IAARC,EAAW,EAAH,MACAC,GAAI,CAAF,qBACR,IAAIC,MAAM,wBAAuB,uBAEtBF,EAASG,OAAM,OAAxB,OAAJpB,EAAO,EAAH,uBACHD,KAAKsB,aAAarB,IAAK,kCAE9Ba,QAAQE,MAAM,wBAAyB,EAAF,IAAS,i0BCzB5B,IAElBO,EAAM,WACV,WAAYC,GAAkB,IAAdC,EAAU,UAAH,6CAAG,CAAC,+FAAC,SAC1BzB,KAAK0B,IAAMF,EACNA,IAGHxB,KAAKyB,QAAUA,EACXzB,KAAK2B,aAAaF,GAClBzB,KAAK4B,oBACT5B,KAAK6B,KAAK7B,KAAK0B,KAEnB,SAwBC,SAxBA,wBACD,SAAKF,GACHM,EAAEN,GAAIO,MAAM/B,KAAKyB,QACnB,GAAC,0BACD,SAAaO,GACX,OAAOC,OAAOC,OAAOlC,KAAK4B,oBAAqBI,EACjD,GAAC,+BACD,WACE,IAAIG,GAAY,EAehB,OAdInC,KAAK0B,IAAIU,UAAUC,SAAS,iBAC9BF,GAAY,GAEO,CACnBG,SAAU,cACVC,UAAU,EACVC,MAAM,EAENC,OAAQN,EACRO,UACE,sEACFC,UACE,qEAGN,0EAAC,EAnCS","sources":["webpack://toxin/./src/components/plugins/DataFetcher.js","webpack://toxin/./src/components/plugins/slickSlider/Slider.js"],"sourcesContent":["export class DataFetcher {\r\n  constructor(mode, filters = {}) {\r\n    this.mode = mode;\r\n    this.filters = filters;\r\n  }\r\n\r\n  get isTest() {\r\n    return this.mode === \"test\";\r\n  }\r\n  getTestData() {\r\n    let data = [];\r\n    for (let i = 1; i < 176; i++) {\r\n      data.push(i);\r\n    }\r\n    return data;\r\n  }\r\n  async #getDataPromise() {\r\n    try {\r\n      const response = await fetch(\"assets/data/apartments.json\");\r\n      if (!response.ok) {\r\n        throw new Error(\"Failed to fetch data\");\r\n      }\r\n      const data = await response.json();\r\n      return this.applyFilters(data);\r\n    } catch (error) {\r\n      console.error(\"Error fetching data: \", error);\r\n    }\r\n  }\r\n  updateFilters(updatedFilters) {\r\n    this.filters = updatedFilters;\r\n  }\r\n  applyFilters(data) {\r\n    const filteredData = data.filter((item) => {\r\n      for (let key in this.filters) {\r\n        const filterValue = this.filters[key];\r\n        const itemValue = item[key];\r\n        // Check if the filter value is an object representing a range\r\n        if (\r\n          typeof filterValue === \"object\" &&\r\n          filterValue.hasOwnProperty(\"min\") &&\r\n          filterValue.hasOwnProperty(\"max\")\r\n        ) {\r\n          const min = filterValue.min;\r\n          const max = filterValue.max;\r\n\r\n          // Check if the item value falls within the range\r\n          if (itemValue < min || itemValue > max) {\r\n            return false;\r\n          }\r\n        } else {\r\n          if (itemValue !== filterValue) {\r\n            return false;\r\n          }\r\n        }\r\n      }\r\n      return true;\r\n    });\r\n    return filteredData;\r\n  }\r\n\r\n  async logData() {\r\n    try {\r\n      const filteredData = await this.#getDataPromise();\r\n      console.log(filteredData);\r\n    } catch (error) {\r\n      console.error(\"Error logging filtered data:\", error);\r\n    }\r\n  }\r\n\r\n  async getData() {\r\n    try {\r\n      const filteredData = await this.#getDataPromise();\r\n      return filteredData;\r\n    } catch (error) {\r\n      console.error(\"Error fetching and filtering data:\", error);\r\n      throw error; // Re-throw the error to propagate it to the caller\r\n    }\r\n  }\r\n}\r\n","import \"slick-carousel\";\r\n\r\nclass Slider {\r\n  constructor(el, options = {}) {\r\n    this.$el = el;\r\n    if (!el) {\r\n      return;\r\n    } else {\r\n      this.options = options\r\n        ? this.mergeOptions(options)\r\n        : this.getDefaultOptions();\r\n      this.init(this.$el);\r\n    }\r\n  }\r\n  init(el) {\r\n    $(el).slick(this.options);\r\n  }\r\n  mergeOptions(opts) {\r\n    return Object.assign(this.getDefaultOptions(), opts);\r\n  }\r\n  getDefaultOptions() {\r\n    let hasArrows = true;\r\n    if (this.$el.classList.contains(\"--no-arrows\")) {\r\n      hasArrows = false;\r\n    }\r\n    let defaultOptions = {\r\n      lazyLoad: \"progressive\",\r\n      infinite: true,\r\n      dots: true,\r\n      // autoplay: true,\r\n      arrows: hasArrows,\r\n      prevArrow:\r\n        \" <button type='button' class='slick-prev icon-arrow_prev'></button>\",\r\n      nextArrow:\r\n        \"<button type='button' class='slick-next icon-arrow_next'></button>\",\r\n    };\r\n    return defaultOptions;\r\n  }\r\n}\r\n\r\nexport { Slider };\r\n"],"names":["DataFetcher","mode","filters","this","data","i","push","updatedFilters","filter","item","key","filterValue","itemValue","hasOwnProperty","min","max","filteredData","console","log","error","fetch","response","ok","Error","json","applyFilters","Slider","el","options","$el","mergeOptions","getDefaultOptions","init","$","slick","opts","Object","assign","hasArrows","classList","contains","lazyLoad","infinite","dots","arrows","prevArrow","nextArrow"],"sourceRoot":""}